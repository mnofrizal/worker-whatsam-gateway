# WhatsApp Gateway PaaS - Hybrid Data Management Plan

## üéØ Hybrid Approach Overview

**Hybrid Data Management** adalah pendekatan yang menggabungkan keunggulan **Centralized** dan **Decentralized** architecture dengan membagi tanggung jawab data berdasarkan **domain bisnis** dan **karakteristik data**.

### üèóÔ∏è Core Principle: Domain-Driven Data Ownership

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   BACKEND       ‚îÇ    ‚îÇ   WORKER        ‚îÇ    ‚îÇ   BAILEYS       ‚îÇ
‚îÇ (Business Data) ‚îÇ‚óÑ‚îÄ‚îÄ‚ñ∫‚îÇ (Session Data)  ‚îÇ‚óÑ‚îÄ‚îÄ‚ñ∫‚îÇ (WhatsApp API)  ‚îÇ
‚îÇ                 ‚îÇ    ‚îÇ                 ‚îÇ    ‚îÇ                 ‚îÇ
‚îÇ ‚Ä¢ Users         ‚îÇ    ‚îÇ ‚Ä¢ Messages      ‚îÇ    ‚îÇ ‚Ä¢ QR Codes      ‚îÇ
‚îÇ ‚Ä¢ Sessions Meta ‚îÇ    ‚îÇ ‚Ä¢ Session State ‚îÇ    ‚îÇ ‚Ä¢ Connections   ‚îÇ
‚îÇ ‚Ä¢ Billing       ‚îÇ    ‚îÇ ‚Ä¢ Media Files   ‚îÇ    ‚îÇ ‚Ä¢ Auth Tokens   ‚îÇ
‚îÇ ‚Ä¢ Analytics     ‚îÇ    ‚îÇ ‚Ä¢ Local Cache   ‚îÇ    ‚îÇ                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üìä Data Ownership Matrix

| Data Type            | Owner   | Storage            | Responsibility                     | Sync Method    |
| -------------------- | ------- | ------------------ | ---------------------------------- | -------------- |
| **User Accounts**    | Backend | PostgreSQL         | Authentication, billing, tiers     | N/A            |
| **Session Metadata** | Backend | PostgreSQL         | Routing, status, worker assignment | Real-time      |
| **API Keys**         | Backend | PostgreSQL         | Authentication, rate limiting      | N/A            |
| **Worker Registry**  | Backend | PostgreSQL + Redis | Health, load balancing             | Heartbeat      |
| **Usage Records**    | Backend | PostgreSQL         | Billing, analytics, compliance     | Batch sync     |
| **System Logs**      | Backend | PostgreSQL         | Audit, troubleshooting             | Real-time      |
| **Messages**         | Worker  | Local DB/File      | Chat history, delivery status      | Event-driven   |
| **Session State**    | Worker  | Local Storage      | Baileys internal state             | Status updates |
| **Media Files**      | Worker  | MinIO/Local        | Images, documents, audio           | On-demand      |
| **QR Codes**         | Worker  | Memory/Cache       | Temporary authentication           | Real-time      |

---

## üîÑ Data Flow Architecture

### 1. Session Creation Flow

```mermaid
sequenceDiagram
    participant U as User/Frontend
    participant B as Backend
    participant W as Worker
    participant WA as WhatsApp

    Note over U,WA: Phase 1: Create Session Card
    U->>B: POST /sessions (create session card)
    B->>B: Create session record (status: DISCONNECTED)
    B-->>U: Session created with ID

    Note over U,WA: Phase 2: Connect Session
    U->>B: POST /sessions/{id}/connect
    B->>B: Find available worker
    B->>W: POST /session/create {sessionId, userId}
    W->>W: Initialize Baileys connection
    W->>WA: Connect to WhatsApp
    WA-->>W: QR Code generated by Baileys

    Note over W,B: QR Code Transfer Methods
    alt Method 1: Direct Response
        W-->>B: HTTP Response with QR data
        B->>B: Store QR in session record
    else Method 2: Webhook Callback
        W->>B: POST /webhook/session-status
        Note right of W: {sessionId, status: "QR_REQUIRED", qrCode: "data:image/png;base64..."}
        B->>B: Update session with QR data
    end

    Note over U,B: Frontend Polling/WebSocket
    U->>B: GET /sessions/{id}/qr (polling)
    B-->>U: QR Code data for display

    Note over U,WA: User Scans QR
    U->>WA: Scan QR with WhatsApp mobile
    WA->>W: Authentication success
    W->>B: POST /webhook/session-status
    Note right of W: {sessionId, status: "CONNECTED", phoneNumber: "+628xxx"}
    B->>B: Update session status
    U->>B: GET /sessions/{id}/status (polling)
    B-->>U: Session now CONNECTED
```

### 2. Message Sending Flow

```mermaid
sequenceDiagram
    participant API as API Client
    participant B as Backend
    participant W as Worker
    participant WA as WhatsApp

    API->>B: POST /api/send (with API key)
    B->>B: Validate API key & session
    B->>B: Get worker from routing table
    B->>W: POST /message/send
    W->>W: Store message locally
    W->>WA: Send via Baileys
    WA-->>W: Delivery confirmation
    W->>W: Update local message status
    W->>B: POST /webhook/message-status
    B->>B: Update usage records
    B-->>API: Success response
```

### 3. Data Synchronization Flow

````mermaid
---

## üîç Detail QR Code Flow Explanation

### Bagaimana Worker Mengirim QR Code ke Backend?

Ada **2 metode** yang bisa digunakan untuk transfer QR Code dari Worker ke Backend:

#### **Method 1: Direct HTTP Response (Synchronous)**
```javascript
// Backend calls Worker
POST http://worker-endpoint/session/create
{
  "sessionId": "user123-personal",
  "userId": "user123"
}

// Worker responds immediately with QR
HTTP 200 OK
{
  "success": true,
  "data": {
    "sessionId": "user123-personal",
    "status": "qr_required",
    "qrCode": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAA...",
    "qrString": "1@ABC123XYZ..."
  }
}
````

**Pros:** Simple, immediate response  
**Cons:** Timeout issues if QR generation takes too long

#### **Method 2: Webhook Callback (Asynchronous) - RECOMMENDED**

```javascript
// Step 1: Backend calls Worker
POST http://worker-endpoint/session/create
{
  "sessionId": "user123-personal",
  "userId": "user123"
}

// Step 2: Worker responds immediately (without QR)
HTTP 202 Accepted
{
  "success": true,
  "data": {
    "sessionId": "user123-personal",
    "status": "initializing"
  }
}

// Step 3: Worker generates QR and calls Backend webhook
POST http://backend-url/api/webhooks/session-status
Authorization: Bearer worker-secret-token
{
  "sessionId": "user123-personal",
  "status": "qr_required",
  "qrCode": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAA...",
  "qrString": "1@ABC123XYZ...",
  "timestamp": "2024-01-15T10:30:00Z"
}
```

**Pros:** No timeout issues, better error handling, scalable  
**Cons:** Slightly more complex implementation

### Frontend Polling untuk QR Code

```javascript
// Frontend polls Backend untuk QR code
async function pollForQRCode(sessionId) {
  const maxAttempts = 30; // 30 seconds
  let attempts = 0;

  while (attempts < maxAttempts) {
    try {
      const response = await fetch(`/api/sessions/${sessionId}/qr`);
      const data = await response.json();

      if (data.success && data.data.qrCode) {
        // Display QR code to user
        displayQRCode(data.data.qrCode);
        return;
      }

      // Wait 1 second before next poll
      await new Promise((resolve) => setTimeout(resolve, 1000));
      attempts++;
    } catch (error) {
      console.error("Error polling QR code:", error);
      attempts++;
    }
  }

  // Timeout - show error to user
  showError("QR code generation timeout");
}
```

### Database Schema untuk QR Storage

```sql
-- Backend database schema
ALTER TABLE sessions ADD COLUMN qr_code TEXT;
ALTER TABLE sessions ADD COLUMN qr_string TEXT;
ALTER TABLE sessions ADD COLUMN qr_expires_at TIMESTAMP;

-- Example data
UPDATE sessions SET
  qr_code = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAA...',
  qr_string = '1@ABC123XYZ...',
  qr_expires_at = NOW() + INTERVAL '2 minutes',
  status = 'QR_REQUIRED'
WHERE id = 'user123-personal';
```

### Implementation Code Examples

#### **Backend Webhook Handler**

```javascript
// src/controllers/webhook.controller.js
class WebhookController {
  async handleSessionStatus(req, res) {
    try {
      const { sessionId, status, qrCode, qrString, phoneNumber } = req.body;

      // Validate worker token
      const workerToken = req.headers.authorization?.replace("Bearer ", "");
      if (workerToken !== process.env.WORKER_AUTH_TOKEN) {
        return res.status(401).json({ success: false, error: "Unauthorized" });
      }

      // Update session in database
      const updateData = { status: status.toUpperCase() };

      if (qrCode) {
        updateData.qrCode = qrCode;
        updateData.qrString = qrString;
        updateData.qrExpiresAt = new Date(Date.now() + 2 * 60 * 1000); // 2 minutes
      }

      if (phoneNumber) {
        updateData.phoneNumber = phoneNumber;
      }

      await prisma.session.update({
        where: { id: sessionId },
        data: updateData,
      });

      res.json({ success: true });
    } catch (error) {
      console.error("Webhook error:", error);
      res.status(500).json({ success: false, error: error.message });
    }
  }
}
```

#### **Backend QR Endpoint**

```javascript
// src/controllers/session.controller.js
class SessionController {
  async getQRCode(req, res) {
    try {
      const { sessionId } = req.params;
      const userId = req.user.userId;

      // Get session with QR code
      const session = await prisma.session.findFirst({
        where: {
          id: sessionId,
          userId: userId,
        },
      });

      if (!session) {
        return res.status(404).json({
          success: false,
          error: "Session not found",
        });
      }

      // Check if QR code exists and not expired
      if (
        !session.qrCode ||
        (session.qrExpiresAt && session.qrExpiresAt < new Date())
      ) {
        return res.json({
          success: true,
          data: {
            status: session.status,
            qrCode: null,
            message: "QR code not available or expired",
          },
        });
      }

      res.json({
        success: true,
        data: {
          sessionId: session.id,
          status: session.status,
          qrCode: session.qrCode,
          qrString: session.qrString,
          expiresAt: session.qrExpiresAt,
        },
      });
    } catch (error) {
      res.status(500).json({ success: false, error: error.message });
    }
  }
}
```

#### **Worker QR Generation**

```javascript
// worker/src/services/baileys.service.js
class BaileysService {
  async createSession(sessionId, userId) {
    try {
      // Initialize Baileys connection
      const { state, saveCreds } = await useMultiFileAuthState(
        `./sessions/${sessionId}`
      );

      const sock = makeWASocket({
        auth: state,
        printQRInTerminal: false, // We'll handle QR ourselves
        logger: pino({ level: "silent" }),
      });

      // Handle QR code generation
      sock.ev.on("connection.update", async (update) => {
        const { connection, lastDisconnect, qr } = update;

        if (qr) {
          // Generate QR code image
          const qrCodeDataURL = await QRCode.toDataURL(qr);

          // Send to Backend via webhook
          await this.reportSessionStatus(sessionId, {
            status: "qr_required",
            qrCode: qrCodeDataURL,
            qrString: qr,
          });
        }

        if (connection === "open") {
          const phoneNumber = sock.user?.id?.split(":")[0];

          // Report successful connection
          await this.reportSessionStatus(sessionId, {
            status: "connected",
            phoneNumber: phoneNumber,
          });
        }
      });

      // Store socket reference
      this.sessions.set(sessionId, { sock, userId });

      return { success: true, sessionId };
    } catch (error) {
      console.error("Session creation error:", error);
      throw error;
    }
  }

  async reportSessionStatus(sessionId, statusData) {
    try {
      await axios.post(
        `${process.env.BACKEND_URL}/api/webhooks/session-status`,
        {
          sessionId,
          ...statusData,
          timestamp: new Date().toISOString(),
        },
        {
          headers: {
            Authorization: `Bearer ${process.env.BACKEND_AUTH_TOKEN}`,
            "Content-Type": "application/json",
          },
        }
      );
    } catch (error) {
      console.error("Failed to report session status:", error);
    }
  }
}
```

### Summary Flow QR Code

1. **User clicks "Connect"** ‚Üí Frontend calls `POST /sessions/{id}/connect`
2. **Backend finds worker** ‚Üí Calls `POST http://worker/session/create`
3. **Worker initializes Baileys** ‚Üí Generates QR code
4. **Worker sends QR to Backend** ‚Üí `POST /api/webhooks/session-status`
5. **Backend stores QR** ‚Üí Updates session record in database
6. **Frontend polls for QR** ‚Üí `GET /sessions/{id}/qr` every 1 second
7. **Backend returns QR** ‚Üí Frontend displays QR code to user
8. **User scans QR** ‚Üí WhatsApp authenticates
9. **Worker detects connection** ‚Üí Reports to Backend via webhook
10. **Frontend polls status** ‚Üí Shows "Connected" status

**Key Points:**

- QR code disimpan di Backend database (temporary, 2 minutes expiry)
- Worker tidak menyimpan QR code (hanya generate dan kirim)
- Frontend polling untuk real-time updates
- Webhook pattern untuk async communication
  sequenceDiagram
  participant W as Worker
  participant B as Backend
  participant DB as Database

      Note over W,DB: Real-time Sync (Critical Data)
      W->>B: Session status updates
      W->>B: Connection events
      W->>B: Error notifications

      Note over W,DB: Batch Sync (Analytics Data)
      W->>W: Accumulate message stats
      W->>B: Hourly usage report
      B->>DB: Update usage records

      Note over W,DB: On-demand Sync (Historical Data)
      B->>W: GET /messages?since=timestamp
      W-->>B: Message history batch
      B->>DB: Store for analytics

````

---

# üè¢ BACKEND PROJECT PLAN

## üìã Backend Responsibilities

### Core Data Management

- **User Management:** Registration, authentication, profile, billing
- **Session Orchestration:** Worker assignment, routing, status tracking
- **API Gateway:** Rate limiting, authentication, request routing
- **Worker Management:** Discovery, health monitoring, load balancing
- **Analytics & Billing:** Usage tracking, reporting, compliance
- **System Administration:** Logs, monitoring, configuration

### Database Schema (PostgreSQL)

```sql
-- Backend owns these tables
CREATE TABLE users (
    id UUID PRIMARY KEY,
    email VARCHAR UNIQUE NOT NULL,
    password_hash VARCHAR NOT NULL,
    role user_role DEFAULT 'USER',
    tier user_tier DEFAULT 'BASIC',
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP DEFAULT NOW()
);

CREATE TABLE sessions (
    id VARCHAR PRIMARY KEY,
    user_id UUID REFERENCES users(id),
    worker_id VARCHAR REFERENCES workers(id),
    name VARCHAR NOT NULL,
    phone_number VARCHAR,
    status session_status DEFAULT 'DISCONNECTED',
    last_seen_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT NOW()
);

CREATE TABLE workers (
    id VARCHAR PRIMARY KEY,
    endpoint VARCHAR UNIQUE NOT NULL,
    status worker_status DEFAULT 'ONLINE',
    session_count INTEGER DEFAULT 0,
    max_sessions INTEGER DEFAULT 50,
    cpu_usage FLOAT DEFAULT 0,
    memory_usage FLOAT DEFAULT 0,
    last_heartbeat TIMESTAMP DEFAULT NOW()
);

CREATE TABLE api_keys (
    id UUID PRIMARY KEY,
    key VARCHAR UNIQUE NOT NULL,
    session_id VARCHAR UNIQUE REFERENCES sessions(id),
    name VARCHAR NOT NULL,
    is_active BOOLEAN DEFAULT true,
    last_used TIMESTAMP,
    created_at TIMESTAMP DEFAULT NOW()
);

CREATE TABLE usage_records (
    id UUID PRIMARY KEY,
    user_id UUID REFERENCES users(id),
    session_id VARCHAR REFERENCES sessions(id),
    api_key_id UUID REFERENCES api_keys(id),
    usage_count INTEGER DEFAULT 0,
    billing_date DATE NOT NULL,
    created_at TIMESTAMP DEFAULT NOW()
);
````

## üöÄ Backend Implementation Phases

### Phase 3A: Worker Orchestration (Week 3)

**Focus:** Worker discovery, health monitoring, load balancing

#### Tasks:

- [ ] **WorkerService Implementation**

  ```javascript
  // src/services/worker.service.js
  class WorkerService {
    async registerWorker(workerId, endpoint, maxSessions)
    async updateWorkerHeartbeat(workerId, metrics)
    async getAvailableWorker()
    async markWorkerOffline(workerId)
    async migrateSessionToAnotherWorker(sessionId)
  }
  ```

- [ ] **Worker Management APIs**

  ```javascript
  // src/controllers/worker.controller.js
  POST / api / admin / workers / register; // Worker self-registration
  PUT / api / admin / workers / { id } / heartbeat; // Health updates
  GET / api / admin / workers; // List workers (admin)
  POST / api / admin / workers; // Add worker (admin)
  DELETE / api / admin / workers / { id }; // Remove worker (admin)
  ```

- [ ] **Load Balancer Service**
  ```javascript
  // src/services/load-balancer.service.js
  class LoadBalancerService {
    async getAvailableWorker()
    async rebalanceSessions()
    async migrateSession(sessionId, sourceWorkerId, targetWorkerId)
  }
  ```

### Phase 3B: Session Management (Week 3)

**Focus:** Two-phase session creation, routing, proxy

#### Tasks:

- [ ] **SessionService Implementation**

  ```javascript
  // src/services/session.service.js
  class SessionService {
    async createSession(userId, sessionId, name)      // Phase 1: Create card
    async connectSession(sessionId)                   // Phase 2: Start connection
    async getSessionStatus(sessionId)
    async deleteSession(sessionId)
    async routeRequest(sessionId, endpoint, data)
  }
  ```

- [ ] **Session Management APIs**

  ```javascript
  // src/controllers/session.controller.js
  POST / api / v1 / sessions; // Create session card
  POST / api / v1 / sessions / { id } / connect; // Start connection
  GET / api / v1 / sessions; // List user sessions
  GET / api / v1 / sessions / { id }; // Get session details
  DELETE / api / v1 / sessions / { id }; // Delete session
  GET / api / v1 / sessions / { id } / qr; // Get QR code
  ```

- [ ] **Proxy Service Implementation**
  ```javascript
  // src/services/proxy.service.js
  class ProxyService {
    async createSessionOnWorker(workerEndpoint, sessionData)
    async getSessionStatus(workerEndpoint, sessionId)
    async deleteSessionOnWorker(workerEndpoint, sessionId)
    async forwardRequest(workerEndpoint, endpoint, data)
  }
  ```

### Phase 3C: Redis Integration (Week 3)

**Focus:** Session routing, worker status caching

#### Tasks:

- [ ] **Redis Schema Design**

  ```javascript
  // Redis data structures
  session_routing: {
    "sessionId1": "workerId1",
    "sessionId2": "workerId2"
  }

  workers: {
    "workerId1": {
      "endpoint": "http://worker1:8001",
      "status": "online",
      "sessionCount": 25,
      "lastHeartbeat": "2024-01-15T10:30:00Z"
    }
  }

  rate_limits: {
    "user:userId1": 150,
    "message_limit:userId1": 45
  }
  ```

- [ ] **Redis Utilities**
  ```javascript
  // src/utils/redis.js
  class RedisManager {
    async setSessionRouting(sessionId, workerId)
    async getSessionWorker(sessionId)
    async updateWorkerStatus(workerId, status)
    async incrementRateLimit(userId, type)
  }
  ```

## üì° Backend-Worker Communication Protocol

### Worker Registration

```javascript
// Worker calls Backend
POST /api/admin/workers/register
{
  "workerId": "worker-001",
  "endpoint": "http://192.168.1.100:8001",
  "maxSessions": 50
}
```

### Health Monitoring

```javascript
// Worker sends heartbeat to Backend
PUT /api/admin/workers/{workerId}/heartbeat
{
  "status": "online",
  "metrics": {
    "sessionCount": 25,
    "cpuUsage": 45.5,
    "memoryUsage": 67.8,
    "activeConnections": 23
  }
}
```

### Session Operations

```javascript
// Backend calls Worker
POST http://worker-endpoint/session/create
{
  "sessionId": "user123-personal",
  "userId": "user123",
  "sessionName": "Personal WhatsApp"
}

// Worker responds to Backend
{
  "success": true,
  "data": {
    "sessionId": "user123-personal",
    "status": "qr_required",
    "qrCode": "data:image/png;base64,..."
  }
}
```

---

# ü§ñ WORKER PROJECT PLAN

## üìã Worker Responsibilities

### Core Session Management

- **Baileys Integration:** WhatsApp connection, authentication, messaging
- **Session State:** Local session storage, state persistence
- **Message Handling:** Send/receive messages, media processing
- **QR Code Generation:** Authentication QR codes
- **Local Data Storage:** Messages, media files, session cache
- **Status Reporting:** Real-time status updates to Backend

### Local Data Storage

```javascript
// Worker manages these data structures
const sessionData = {
  sessionId: "user123-personal",
  userId: "user123",
  baileys: {
    // Baileys internal state
    creds: {...},
    keys: {...}
  },
  status: "connected",
  phoneNumber: "+6281234567890",
  lastActivity: "2024-01-15T10:30:00Z"
};

const messageQueue = [
  {
    id: "msg_001",
    sessionId: "user123-personal",
    to: "6281234567890@s.whatsapp.net",
    type: "text",
    content: "Hello World",
    status: "pending",
    timestamp: "2024-01-15T10:30:00Z"
  }
];
```

## üöÄ Worker Implementation Phases

### Phase 3A: Core Worker Setup (Week 3)

**Focus:** Basic Baileys integration, REST API server

#### Tasks:

- [ ] **Express Server Setup**

  ```javascript
  // worker/src/app.js
  const express = require("express");
  const app = express();

  // Health check endpoint
  app.get("/health", healthController.getHealth);

  // Session management endpoints
  app.post("/session/create", sessionController.createSession);
  app.get("/session/:id/status", sessionController.getStatus);
  app.delete("/session/:id", sessionController.deleteSession);

  // Message endpoints
  app.post("/session/:id/send", messageController.sendMessage);
  app.get("/session/:id/messages", messageController.getMessages);
  ```

- [ ] **Baileys Integration**

  ```javascript
  // worker/src/services/baileys.service.js
  class BaileysService {
    async createSession(sessionId, userId)
    async connectSession(sessionId)
    async sendMessage(sessionId, to, message)
    async getSessionStatus(sessionId)
    async destroySession(sessionId)
  }
  ```

- [ ] **Session Storage**
  ```javascript
  // worker/src/services/storage.service.js
  class StorageService {
    async saveSessionState(sessionId, state)
    async loadSessionState(sessionId)
    async saveMessage(sessionId, message)
    async getMessages(sessionId, filters)
    async deleteSession(sessionId)
  }
  ```

### Phase 3B: Backend Communication (Week 3)

**Focus:** Registration, heartbeat, status reporting

#### Tasks:

- [ ] **Backend Client**

  ```javascript
  // worker/src/services/backend.service.js
  class BackendService {
    async registerWorker()
    async sendHeartbeat(metrics)
    async reportSessionStatus(sessionId, status)
    async reportMessageStatus(messageId, status)
  }
  ```

- [ ] **Worker Registration Flow**

  ```javascript
  // worker/src/startup.js
  async function startWorker() {
    // 1. Start Express server
    const server = app.listen(PORT);

    // 2. Register with Backend
    await backendService.registerWorker();

    // 3. Start heartbeat
    setInterval(sendHeartbeat, 30000);

    // 4. Load existing sessions
    await loadPersistedSessions();
  }
  ```

- [ ] **Health Monitoring**
  ```javascript
  // worker/src/controllers/health.controller.js
  class HealthController {
    getHealth(req, res) {
      const metrics = {
        status: "online",
        sessionCount: sessionManager.getActiveSessionCount(),
        cpuUsage: process.cpuUsage(),
        memoryUsage: process.memoryUsage(),
        uptime: process.uptime(),
      };
      res.json({ success: true, data: metrics });
    }
  }
  ```

### Phase 3C: Message Processing (Week 3)

**Focus:** Send/receive messages, media handling

#### Tasks:

- [ ] **Message Controller**

  ```javascript
  // worker/src/controllers/message.controller.js
  class MessageController {
    async sendMessage(req, res) {
      const { sessionId } = req.params;
      const { to, type, message, media } = req.body;

      // 1. Validate session
      // 2. Send via Baileys
      // 3. Store locally
      // 4. Report to Backend
      // 5. Return response
    }

    async getMessages(req, res) {
      // Return local message history
    }
  }
  ```

- [ ] **Media Processing**
  ```javascript
  // worker/src/services/media.service.js
  class MediaService {
    async processImage(buffer, sessionId)
    async processDocument(buffer, filename, sessionId)
    async processAudio(buffer, sessionId)
    async getMediaUrl(mediaId)
  }
  ```

## üì° Worker-Backend Communication Protocol

### Status Updates

```javascript
// Worker reports to Backend
POST http://backend-url/api/admin/workers/{workerId}/status
{
  "sessionId": "user123-personal",
  "status": "connected",
  "phoneNumber": "+6281234567890",
  "lastActivity": "2024-01-15T10:30:00Z"
}
```

### Message Status Updates

```javascript
// Worker reports message delivery
POST http://backend-url/api/webhooks/message-status
{
  "sessionId": "user123-personal",
  "messageId": "msg_001",
  "status": "delivered",
  "timestamp": "2024-01-15T10:30:00Z"
}
```

---

# üîÑ Integration & Synchronization

## üìä Data Sync Strategies

### 1. Real-time Sync (Critical Data)

- **Session Status:** Worker ‚Üí Backend (immediate)
- **Connection Events:** Worker ‚Üí Backend (immediate)
- **Error Notifications:** Worker ‚Üí Backend (immediate)

### 2. Batch Sync (Analytics Data)

- **Message Statistics:** Worker ‚Üí Backend (hourly)
- **Usage Metrics:** Worker ‚Üí Backend (daily)
- **Performance Data:** Worker ‚Üí Backend (hourly)

### 3. On-demand Sync (Historical Data)

- **Message History:** Backend ‚Üê Worker (when requested)
- **Media Files:** Backend ‚Üê Worker (when requested)
- **Session Logs:** Backend ‚Üê Worker (for troubleshooting)

## üîß Configuration Management

### Backend Configuration

```javascript
// backend/.env
DATABASE_URL=postgresql://user:pass@localhost:5432/whatsapp_gateway
REDIS_URL=redis://localhost:6379
WORKER_AUTH_TOKEN=worker-secret-token
WORKER_HEALTH_CHECK_INTERVAL=30000
```

### Worker Configuration

```javascript
// worker/.env
WORKER_ID=worker-001
WORKER_PORT=8001
BACKEND_URL=http://localhost:8000
BACKEND_AUTH_TOKEN=worker-secret-token
SESSION_STORAGE_PATH=./sessions
MEDIA_STORAGE_PATH=./media
```

---

# üéØ Implementation Timeline

## Week 3: Core Integration

- **Backend:** Worker orchestration, session management
- **Worker:** Baileys integration, basic messaging
- **Integration:** Registration, heartbeat, status sync

## Week 4: Advanced Features

- **Backend:** Load balancing, session migration
- **Worker:** Media processing, message queuing
- **Integration:** Batch sync, error handling

## Week 5: Production Ready

- **Backend:** Analytics, monitoring, admin APIs
- **Worker:** Performance optimization, resilience
- **Integration:** Full hybrid data flow, testing

---

# üìã Development Checklist

## Backend Tasks

- [ ] WorkerService implementation
- [ ] SessionService with two-phase creation
- [ ] ProxyService for worker communication
- [ ] Redis integration for routing
- [ ] Load balancer algorithms
- [ ] Admin APIs for worker management
- [ ] Health monitoring system
- [ ] Session migration logic

## Worker Tasks

- [ ] Express server with REST APIs
- [ ] Baileys service integration
- [ ] Session state management
- [ ] Message processing pipeline
- [ ] Media handling service
- [ ] Backend communication client
- [ ] Local storage implementation
- [ ] Health reporting system

## Integration Tasks

- [ ] Worker registration protocol
- [ ] Heartbeat mechanism
- [ ] Status synchronization
- [ ] Message delivery tracking
- [ ] Error handling and recovery
- [ ] Data consistency validation
- [ ] Performance monitoring
- [ ] End-to-end testing

---

**Project:** WhatsApp Gateway PaaS  
**Architecture:** Hybrid Data Management  
**Backend Project:** be-whatsam-gateway  
**Worker Project:** [Your Worker Project Name]  
**Integration Timeline:** Week 3-5
